## Chapter 8: Debugging
>[!quote] Debuggers help in the process of developing software, since programs usually have errors in them when they are first written.
- kernel debugging is hard, because your debugger is also running on the [[kernel]]. So if you pause execution of the kernel, everything pauses
	- Kind of like how a stopwatch that stops time seems like a brilliant idea until you realise that you, too, are a creature of Time and now you can't unfreeze it because you can't move because you froze time.
	- (idiot)
- so you need to do the debugging on a different system
- as it stands, only [[WinDbg]] does kernel debugging
- [[malware]] analysts like [[OllyDbg]], but it doesn't support kernel debugging
- both [[WinDbg]] and [[IDA Pro]] support user-mode debugging, but they're not as feature-rich as [[OllyDbg]]
- there are two kinds of exception: first-chance and second-chance
- a first-chance exception catches a runtime exception, such as an `IndexError` or a `DivideByZero` error. This should be handled by an exception handler, written by the engineer
- a second-chance exception is one that would cause the program to crash, and so if control is handed to the debugger the exception must be resolved before the program can continue executing

>[!quote] Malware may intentionally generate first-chance exceptions in order to make the program difficult to debug

- Again it seems that any sufficiently advanced software is indistinguishable from [[malware]]
## Chapter 18: Packers and unpacking
- a packer works by transforming an executable into data and an unpacking stub. This reduces the size and also obfuscates the code. This is handy for [[malware]], and also so that disgraceful amount of [[javascript]] you've jammed into your webapp can be more easily dumped onto some poor sucker's mobile phone
	- bitter? Me? No!
- an analyst will be able to see the stub, but then has to understand it to make sure that it doesn't do anything surprising
	- 'surprising' is a euphemism here, for 'bad'
- the stub doesn't perfectly unpack the executable - it will be slightly different to the original. It will have a [[Portable Executable|PE]] header that's slightly different, and there may be some cruft that the packer's generated
	- like how you never come back from the dead exactly the same
### Identifying a packed program
- it has very few imports, and they're generally `LoadLibrary` and/or `GetProcAddress`
	- this is a kind of bootstrapping, because with these the unpacker can get the rest of the imports in place
- if the program is opened in [[IDA Pro]], the automatic analysis only shows a snippet
- [[OllyDbg]] will warn that the program may be packed
- there may be section names that give the game away, eg `UPX0`
- or there may be abnormal section sizes, such as a `.text` section that's got raw data size 0 but virtual size...not zero
- there are also tools such as [[PEiD]] that can tell you
- [[entropy]] is a nice proxy, because encrypted or compressed data generally has high entropy - it looks more random
## Chapter 19: [[Shellcode]] analysis
## Chapter 21: [[64-bit]] [[malware]]
